using System;

namespace AutoGenerated.Sorting.QuickSort
{
    // The type supplies quick sort algorithms to sort an array
    public class QuickSorter
    {

        public void QuickSort<T>(T[] array, IPivotElementStrategy pivotElementStrategy)
            where T : IComparable<T>
        {
            QuickSortImplementation(array, 0, (array.Length - 1), pivotElementStrategy);
        }

        private void QuickSortImplementation<T>(T[] array, int lowIndex, int topIndex, IPivotElementStrategy pivotElementStrategy)
            where T : IComparable<T>
        {
            if ((lowIndex < topIndex))
            {
                int borderIndex = Partition(array, lowIndex, topIndex, pivotElementStrategy);
                QuickSortImplementation(array, lowIndex, borderIndex, pivotElementStrategy);
                QuickSortImplementation(array, (borderIndex + 1), topIndex, pivotElementStrategy);
            }
        }

        private int Partition<T>(T[] array, int lowIndex, int topIndex, IPivotElementStrategy pivotElementStrategy)
            where T : IComparable<T>
        {
            T pivot = pivotElementStrategy.GetPivot(array, lowIndex, topIndex);
            int leftToRight = lowIndex;
            int rightToLeft = topIndex;
            for (
            ; true;
            )
            {
                for (
                ; ((leftToRight < topIndex)
                            && (array[leftToRight].CompareTo(pivot) < 0));
                )
                {
                    leftToRight = (leftToRight + 1);
                }
                for (
                ; ((rightToLeft > lowIndex)
                            && (array[rightToLeft].CompareTo(pivot) > 0));
                )
                {
                    rightToLeft = (rightToLeft - 1);
                }
                if ((leftToRight < rightToLeft))
                {
                    T temp = array[leftToRight];
                    array[leftToRight] = array[rightToLeft];
                    array[rightToLeft] = temp;
                    leftToRight = (leftToRight + 1);
                    rightToLeft = (rightToLeft - 1);
                }
                else
                {
                    if ((rightToLeft == topIndex))
                    {
                        return (topIndex - 1);
                    }
                    else
                    {
                        return rightToLeft;
                    }
                }
            }
        }
    }


    public interface IPivotElementStrategy
    {

        T GetPivot<T>(T[] array, int lowIndex, int topIndex)
            where T : IComparable<T>;
    }

    public class FirstElementPivotStrategy : IPivotElementStrategy
    {

        public T GetPivot<T>(T[] array, int lowIndex, int topIndex)
            where T : IComparable<T>
        {
            if ((array == null))
            {
                throw new ArgumentNullException("array");
            }
            if ((array.Length == 0))
            {
                throw new InvalidOperationException("length less than 0");
            }
            return array[lowIndex];
        }
    }
    
    public class LastElementPivotStrategy : IPivotElementStrategy
    {

        public T GetPivot<T>(T[] array, int lowIndex, int topIndex)
            where T : IComparable<T>
        {
            if ((array == null))
            {
                throw new ArgumentNullException("array");
            }
            if ((array.Length == 0))
            {
                throw new InvalidOperationException("length less than 0");
            }
            return array[topIndex];
        }
    }
    
    public class HalfWayPivotStrategy : IPivotElementStrategy
    {
        public T GetPivot<T>(T[] array, int lowIndex, int topIndex) where T : IComparable<T>
        {
            if ((array == null))
            {
                throw new ArgumentNullException("array");
            }
            if ((array.Length == 0))
            {
                throw new InvalidOperationException("length less than 0");
            }

            return array[lowIndex + (topIndex - lowIndex) / 2];
        }
    }
}
